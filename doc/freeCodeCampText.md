指定文字该如何降级
设置图片的尺寸
增加边框包围图片
设置边角弧度
使用border-radius创建圆形图像
给DIV设置背景颜色
给选择器设置id
给id设置属性
调整元素内边距
调整元素外边距
给元素添加负外边距
给元素不同的边设置不同的内边距
给元素不同的便设置不同的外边距
-----------------------------------------
通过元素选择器设置属性
懂的相对单位和绝对单位
设置HTML body的元素
继承body的元素属性
从多种风格中优选一种风格
在后续重写元素样式的风格
通过ID属性覆盖类样式属性
使用内联样式覆盖类声明
使用！important来覆盖所有的声明
使用特定的16进制代码
使用特定的十六进制代码来混合颜色
使用缩写的十六进制代码编写颜色
------------
使用RGB值来给颜色赋值
使用RGB值混合颜色
使用CSS变量一次改变多种元素
创建自定义CSS变量
使用自定义变量
将后备值加到CSS变量后
改善浏览器回退的问题
级联CSS变量
改变特定区域的变量
使用media查询来改变变量



应用视觉设计：使用text-algin属性创建视觉平衡
应用视觉设计：使用width属性调整元素宽度
应用视觉设计：使用height属性调整元素高度
使用strong标签让字体加粗
使用u标签让字体有下划线
使用em标签让字体倾斜
使用s标签让字体呈现删除线
使用hr标签创建水平横线
调整文字的背景颜色元素
调整标题和段落文字的大小
-------------------
给卡片元素增加盒子阴影
降低的不透明度
使用文本转化属性使文本变成全大写
给不同的标题设置文字大小
给不同的标题设置文字粗细
给段落设置文字大小
给段落设置行高
调整覆盖状态的另一个标签
改变元素的相对位置
使用CSS来改变元素的相对位置
------------
使用绝对定位锁定其与父元素的位置
使用固定位置把元素锁在浏览器窗口
使用浮动元素向左或右推动
使用z-index改变重叠元素的位置
使用margin属性使div水平居中
了解互补色
将各种颜色调为互补色
调整颜色的色调
创建CSS样式颜色的渐变
使用CSS渐变色创建条纹元素
----------
通过添加细微图案作为背景图像来创建纹理
通过使用CSS的Transform scale属性来改变元素的大小
通过使用skewX的属性让元素沿着X轴倾斜
通过使用skewY的属性让元素沿着Y轴倾斜
使用CSS创建图形
通过CSS和HTML创建更复杂的形状
了解CSS的@keyframes和动画属性的工作原理
使用CSS动画更改按钮的悬停状态
修改动画的填充模式
使CSS动画创建运动
----------------
通过从左到右淡化元素来创建视觉方向
使用无限的动画计数使动画元素不停的运动
使用无限跳动计数制作CSS心跳
设置动画的可控速率
设置复杂动画的可控速率
用关键词改变动画时间
了解贝塞尔曲线的工作原理
使用贝塞尔曲线移动图形
使用贝塞尔曲线使运动更自然


-------------------
为视力受损的辅助功能添加图像替代文字
使用标题显示内容的层次关系
使用主元素直接跳转到内容
文章元素中的包装内容
使用标题Landmark使屏幕阅读器导航更容易
使用导航Landmark使屏幕阅读器导航更轻松
使用页脚Landmark使屏幕阅读器导航更容易
使用audio元素提高音频内容的可访问性
使用图元素提高图表的可访问性
使用label元素提高表单领域的可访问性
------------
在fieldset元素中包裹单选按钮以获得更好的可访问性
添加无障碍的日期选择器
使用H5 datetime 元素标准化日期时间
使用自定义CSS使元素仅对屏幕阅读器可见
提高高对比度文本的可读性
使用足够的对度避免色盲问题
通过仔细选择传达信息的颜色来防止色盲问题
使用描述性链接文本提供链接含义
使链接可以使用HTML访问密钥进行导航
使用tabindex将键盘焦点添加到元素
使用tabindex指定多个元素的键盘焦点顺序
-------------------------------------------------------------------------------

响应式WEB设计原则：

创建媒体查询
使图像响应
将Retina图像用于更高分辨率的显示器
使排版响应

-----------------------

CSS Flexbox 挑战简介：

flex 定位两个box
将 Flex Superpowers 添加到 Tweet Embed 中
使用 flex-direction 属性创建横向排列
在Tweet Embed中应用flex-direction属性创建行
使用 flex-direction 属性创建纵向排列
在Tweet Embed中应用flex-direction属性创建行
----------------------------------------------------------------
使用 justify-content 属性设置居中元素
在Tweet Embed中应用 justify-content 属性
使用align-items 属性设置居中元素
使用 flex-wrap 属性包装行或者列
使用flex-shrink属性收缩项目
使用flex-grow属性扩展项目
使用 flex-basis 属性设置项的初始大小
使用flex 速记属性
使用order属性重新排列项目
使用 align-self  属性

-----Introduction to the CSS Grid Challenges(CSS网格挑战简介)-------

创建第一个CSS网格
使用 grid-template-columns 添加列
使用 grid-template-rows 添加行
使用 css 网格单元改变网格的行和列的值
使用 grid-column-gap 创建表格列间隙
使用 grid-row-gap 创建表格行间隙
使用 grid-gap 更快的添加表格间隙
使用 grid-column 控制列的间距
使用 grid-row 控制行的间距
使用 justify-self 水平对齐项目
----------------------
使用align-self 垂直对齐项目
使用 justify-items 使所有项目水平对齐
使用 align-items 使用所有项目垂直对齐
将网格划分为区域模块
使用grid-area 属性在网格区域中存放项目
使用 grid-area 而不创建区域模块
使用重复函数减少重复
使用 minmax 函数限制 每项的尺寸
使用 auto-fill 创建灵活的布局
使用 auto-fit 创建灵活的布局
使用 @Media 创建响应式布局
在网格中创建网格
-------------------

-----Basic JavaScript（基础JavaScript ）----

评价你的js编码
声明 JavaScript 变量
使用赋值运算符存储值
使用赋值运算符初始化变量
理解未初始化的变量
了解变量中的大小写敏感度
用JavaScript使两数相加
使用JavaScript进行两数相减
使用JavaScript让两数相乘
使用JavaScript让两数相除

---
使用JavaScript增加数字
使用JavaScript减少数字
使用JavaScript创建浮点数
使用JavaScript使两个小数相乘
使用JavaScript使两个小数相除
在JavaScript查找余数
使用+=
使用-=
使用*=
使用/=
-----
声明字符串变量
转义字符中的文字引号
使用单引号引用字符
字符串的转义序列
使用 + 运算符链接字符串
使用 += 运算符连接字符串
使用变量构造字符串
将字符附加到字符串
查询字符串的长度
使用括号表示法查找字符串中的第一个字符
---
理解字符串不变性
使用括号表示法查找字符串中的第N个字符
使用括号表示法查找字符串中的最后一个字符
使用括号表示法查找第N个到最后一个字符
Word Blanks游戏
使用一个 JavaScript 数组存储多个变量
在一个数组中嵌套另一个数组
使用索引修改数组数据
访问带索引的多维数组
使用 push() 操作数组
--
使用 shift() 操作数组
使用 unshift() 操作数组
购物清单
使用函数编写可用的JavaScript
将值传递给带参数的函数
全局范围和函数
局部范围和函数
在函数中对比全局范围和本地范围
从带返回函数中返回值
具有返回值的赋值	
---
排队等候
学习Boolean值
使用条件逻辑和 if 语句
Equality 运算符的比较
练习比较不同的值
不等运算符的比较
严格比较不等运算符
大于运算符的比较
大于等于运算符的比较
小于运算符的比较
---
小于等于运算符的比较
逻辑&&运算符的比较
逻辑 ||运算符的比较
else的介绍
else if 的介绍
If Else语句中的逻辑顺序
链接 if else 语句
使用Switch选择多种选择情况
在switch语句中添加 default
在swtich语句中的多种相同选项
---
用switch 语句替换 if else 链
从函数中返回布尔值
数卡片
构建JavaScript对象
使用点表示法来访问对象属性
使用括号表示法来访问对象属性
使用变量访问对象属性
更新对象属性
给JavaScript对象新增一个属性
给JavaScript对象删除一个属性	
------
使用对象进行查找
测试对象的属性
操作复杂对象
访问嵌套对象
访问嵌套数组
记录集合
再循环时使用while进行迭代
使用 iterate 进行迭代循环
使用 iterate 循环迭代偶数
使用 Loop向后计数
----
使用 For 循环遍历数组
嵌套循环
使用 do..while 遍历循环
查找配置文件
使用JavaScript生成随机分数
使用 JavaScript 生成随机整数
在范围内生成随机整数
在方法中使用 parseInt
将二进制数转化为十进制数使用parseInt(str,radix)
使用条件三元运算符
--
使用多个条件三元运算符

---------------------ES6---------------------------------
探索var和let关键字之间的不同
比较var和let关键字的范围
使用 只读变量申明 const 关键字
使用 const 声明一个数组
防止对象突变
使用箭头函数编写简明的匿名函数
将参数写入箭头函数中
编写高阶箭头函数
设置函数的默认参数
将 Rest 运算符和函数参数一起使用
 使用 Spread 运算符来就地评估数组
使用结构分配从对象分配变量
使用解构分配从嵌套对象分配变量
使用解构函数从数组中分配变量
使用 Rest 运算符来重新分配数组元素
使用解构函数将函数的参数传递
使用模板文字创建字符串
使用简单字段编写简明对象文字声明
使用ES6编写简明声明函数
使用类语法定义函数结构
---
使用 getters 和 setters 来控制对象的访问
掌握 Import 和 require 的不同
使用导出的重用代码块
使用 * 导入文件中的所有东西
使用默认导出创建导出回退
导入默认导出
-------------正则表达式----

使用 Test 的方法
匹配文本字符串
使用不同的可能性匹配文本字符串
匹配时忽略大小写
--
提取匹配
找到的不只是第一个匹配
与任何通配符匹配
将单个字符与多种可能性匹配
匹配字母表中的字母
匹配字母表中的数字和字母
匹配未指定的单个字符
匹配出现一次或多次的字符
匹配出现零次或多次的字符
使用延迟匹配查找字符
--
在狩猎中找到一个或多个罪犯
匹配起始字符串模式
匹配结束字符串模式
匹配所有的字母和数字
匹配所有字符除字母和数字
匹配所有数字
匹配所有非数字
限制用户名的可能性
匹配空格
匹配非空格的字符
---
指定匹配上限和下限字符串的模式
匹配只有下线字符串的模式
匹配确定的字符数的模式
检测全部或者全无
正面前瞻和负面前瞻
使用捕获组的重用模式
使用捕获组进行搜索和替换
删除开头和结尾的空格
--------------调试-----------------

使用 JavaScript 控制台检查变量的值	
了解FreeCodeCamp和浏览器之间对 console 的区别
使用 typeof 检查变量的类型
捕获拼写错误的变量和函数名
捕获未闭合的括号，大括号，引号
捕获单引号和双引号的混合用法
捕获使用赋值运算符而不是相等运算符
函数调用后缺少左括号或者右括号
函数调用时那错误的顺序传递参数
使用索引时捕获一个错误
---
在循环内重新初始化变量时要小心		
防止具有有效终端条件的无限循环

-------------------基本数据结构---------
使用数组存储数据集合
使用数组表示法访问数组的内容
使用 push() 和 unshift() 添加数组内容
使用 pop() 和 shift() 删除数组内容
使用 splice() 删除数组内容
使用 splice() 添加数组内容
使用 slice() 添加复制数组
使用 ES6 复制数组
将数组与 ES6 结合
使用 indexOf() 检查元素的索引
循环遍历数组的所有项

创建复杂的多维数组
向JavaScript对象添加键值对
修改嵌套在对象中的对象
使用括号表示法访问属性名称
使用删除关键字删除对象的属性
检查对象是否具有属性
使用 for..in 中的对象键进行迭代
使用 Object.keys 生成所有对象键的数组
修改储存在对象中的数组
将摄氏度转换为华氏度
将字符串倒转
Factorialize a Number
查找字符串中最长的单词
返回数组中最大的数字
确认结束
重复字符串
截断字符串
Finders Keepers
Boo who
标题 case 的句子
Slice 和 Splice
删除数组中所有有价值的数据
数据排序，并获取新数字的顺序
第一个字符串的字符是否包含了第二个字符串
猴子吃香蕉-截取数组
创建一个基本的 JavaScript 对象
使用点表示法访问属性对象
在对象上创建方法
使用此关键字使代码可以重用
定义构造函数
---
使用构造函数创建对象
扩展构造函数以接收函数
使用 instanceof 验证对象的构造函数
了解自己的属性 duck.hasOwnProperty(property)
使用原型属性来减少重复的代码 Bird.prototype.numLegs = 2;
遍历对象的所有属性
了解构造函数的属性		candidate.constructor === Bird
将原型变成新对象
记住在更改原型设置构造函数属性
了解对象原型的来源 Dog.prototype.isPrototypeOf(beagle);
--
了解原型链 Object.prototype.isPrototypeOf(Dog.prototype);	
使用继承，所以你不要自己重复自己
从超类继承行为	let dog  = new Animal();
将 child 的 Prototype 设置位 Parent 的实例 	Dog.prototype = Object.create(Animal.prototype);
重置继承构造函数的属性	Dog.prototype.constructor = Dog;虽然是继承，但是构造函数是自己的。
继承后添加方法	1、继承实例 2、重置构造方法 3、设置自己的方法
重写继承方法	Dog.prototype.方法 = function(){}
使用 Mixin 在不相关的对象之间添加属性	let Mixin = function(obj) {}
使用闭包保护对象内的属性不被外部修改 	let 属性；this.get = function(){return 属性；}
理解立即执行函数的表达式	(function(){})()
--
使用立即执行函数创建一个模块 	立即执行函数里return{isCuteMixin:function(obj) {}}

--------------- Functional Programming Challenges(功能编程挑战)-------

了解功能编程	const getTea = (numOfCups) => {}
理解功能编程术语	
了解使用命令代码的危害
使用功能编程避免突变和副作用
传递参数以避免函数中的外部依赖
重构函数的全局变量		list.filter((item) => item !== bookName);
使用 map 方法从数组中提取数据
在Prototype 上实现 map	this.forEach(a => newArray.push(callback(a)));
使用过滤器方法从数组中提取数据	
在 Prototype 上实现过滤器的方法	this.forEach(function(x){callback(x)})

使用切片返回数组的一部分	return anim.slice(beginSlice,endSlice);
使用切片从阵列中删除元素，而不用 splice	
使用 concat 联合两个数组
添加元素到数组的末尾，使用concat 而不是 push
使用 reduce 方法分析数据
使用 sort 方法将数组按字母顺序进行排序		return arr.sort(function(a,b) {
return a>b;
});
返回排序数组而不更改原始数组	return [].concat(arr).sort(function(a,b){return 1-b;})
使用 split方法将字符串拆分为数组	return arr.split(/\W/);
使用 join 方法将数组结合进字符串中	return arr.split(/\W/).join(' ');
--
应用函数式编程将字符串转换为 URL Slugs	return title.split(/\W/).filter((obj) => {return obj !== ' '}).join('-').toLowerCase();

使用 every 方法检查数组中的每个元素是否符合条件 return arr.every(item => item>0)
使用 some 方法检查数组中任何元素是否符合条件	同上
Currying和Partial Application简介	add(10)(20); function add(x){return function(y){x+y}}

----------------------Intermediate Algorithm Scripting(中间算法脚本)-------------------------

对范围中的所有数字求和	
差分两个数组
寻找和销毁
因此你是艺术家	if(!obj.hasOwnProperty(aa[i]) || obj[aa[i]] !== source[aa[i]]){
return false;}
脊椎龙头案例	str.split(/\s|_|(?=[A-Z])/).join('-').toLowerCase();
Pig Latin
----
查找和重复	var re = new RegExp(before,'gi');
DNA配对		
失去的字符 	a+= String.fromCharCode(str[0].charCodeAt(0) + i);
排序联盟		while(arguments[i]){ a = a.concat(arguments[i])}
转换 HTML 实体	str.split(' ').map(item => a[item] || item).join(' ');
---
求和所有奇数斐波纳契数	
统计所有素数	Array.from({length:num+1},(v,k) => k	)
找出所有数字中的最小公倍数	
删除它	return arr.slice(arr.findIndex(func) >= 0 ? arr.findIndex(func): arr.length, arr.length);
展平嵌套数组	flat.some(Array.isArray) ? steamrollArray(flat):flat;
二进制代理	String.fromCharCode(...str.split(' ').map(item => {
    return parseInt(item,2);  
  }))
---
一切都是真的	return collection.every(obj => obj[pre]);
参数可选
创建一个人
回文检查器
Caesar cipher	String.fromCharCode.apply(String, a);
电话号码验证器	var regex = /^(1\s?)?(\(\d{3}\)|\d{3})[\s\-]?\d{3}[\s\-]?\d{4}$/;

-------------Bootstrap-------------
使用具有Bootstrap Fluid Containers的响应式设计	<div class="container-fluid"></div>
使用图像移动响应		<img class=" img-responsive" 
带 bootstrap 的文本中心	class="red-text  text-center"
创建一个bootstrap 按钮	
创建一个块级按钮
尝试按钮颜色
--
使用btn-info 调出可选框架	<button class="btn btn-block btn-info">Info</button>
用btn-danger警告你的危险行为用户
使用Bootstrap网格并排放置元素	<div class="row"><div class="col-xs-4"></div></div>
使用 Bootstrap 摆脱 css
使用跨度来定位内联元素
创建自定义标题
-
向按钮增加真棒图标
给全部按钮都增加图标
响应样式的单选按钮
响应样式的多选按钮
input 作为 from 表单的控件
响应 排列表单元素
创建 bootstrap 标题
将DIV 放到 fluid div 中
创建 bootscrap row
拆分 bootstrap row
---
创建 bootstrap wells
添加元素到 wells 中
添加默认的 按钮元素
给每个按钮增加 target 类
给 wells 组件增加 label 标签
给每个元素唯一的id	16

学习<script> 和 $(document).ready(function(){});	
使用$ 选择器定位元素			$("button").addClass("animated bounce");
定位 class 元素				$(".text-primary").addClass("animated shake");
定位 id 元素
--				
删除 function 
使用多个 选择器定位相同的元素
删除元素的类
使用 jq 更改元素的 CSS			$("#target1").css("color", "red");
使用 jq 禁用元素				$('#target1').prop('disabled', true);
使用 jq 更改元素内的文本			$("h3").html("<em>jQuery Playground</em>");
使用 jq 删除 元素				$('#target4').remove();
使用 appendTo 移动元素			$('#target2').appendTo('#right-well');
使用 jq 克隆元素				$('#target5').clone().appendTo('#left-well');
使用 jq 定位父级元素			$("#target1").parent().css("background-color", "red");
---
使用 jq 定位子级元素			$('#right-well').children().css('color','orange');
使用 jq 定位子级特定的元素			$('.target :nth-child(2) ').addClass('animated bounce'); 
使用 jq 定位偶数元素			$('.target:even').addClass('animated shake');
  });
使用 jq 修改整个页面			$('body').addClass('animated hinge');
18
使用 SASS变量存储数据			.blog-post {
    color: $text-color;
  }
使用 Sass 嵌套 css
使用 Minins 创建可重用的 CSS			@mixin border-radius($x) {
    border-radius: $x;
  }
使用 @if 和 @else 添加逻辑判断		@if $bool == true {	}  @else if $val == alert { }
使用 @for 创建 sass 循环			@for $i from 1 through 5 {
    .text-#{$i} {font-size: 10 * $i;}
}
使用 @each 遍历 map 上的每一项 		@each $i in blue, black, red {
    .#{$i}-bg {background-color: $i}
  }
--
使用 @while 循环直到满足条件			@while $i<11 {
    .text-#{$i} {font-size: 5*$i;}
    $i: $i+1;
  }
使用 Partials 将样式分成更小的块
将一组 CSS 样式扩展到 另一个文件中		@extend .info;
9
创建一个简单的 JSX 元素
创建一个复杂的 JSX 元素
在jsx 中添加注释				{/* */}
将 html 元素渲染到 dom			ReactDOM.render(JSX, document.getElementById('challenge-node'));
在 html 中定义jsx 类
了解自我关闭的 jsx 标签
--
创建一个无状态组件				const MyComponent = function() {}
创建一个 React 组件
使用一个 Composition 创建组件
使用  React 渲染嵌套组件	
撰写React组件
--
将类组件渲染到 DOM 上
从 Scratch 编写 一个 React 组件
传递数据给无状态组件
传递一个数据给无状态组件
使用默认的属性				ShoppingCart.defaultProps = {
  items: 0
}
重写默认属性	
--			
使用 PropTypes 设置参数的类型		Camper.propTypes = {name: PropTypes.string.isRequired};	
使用 this.props 访问属性
使用无状态组件检查属性			const Camper = props => (<p>{props.name}</p>);
创建有状态组件				
在用户界面中渲染 state			
用户界面中渲染 state 的另一种方式
通过 this.setState 设置 state
将方法绑定 this				this.addItem = this.addItem.bind(this);
使用 state 切换 元素				
编写一个简单的计数器
创建一个可控制的输入框			
创建一个可控制的表单
将状态作为参数传递给子组件	
---
通过callback传递 props参数
使用声明周期的方法： componentWillMount	在之前调用render()当组件被安装到所述DOM方法
使用声明周期的方法： componentDidMount	对setState()此处的任何调用都将触发重新呈现组件
增加监听事件				document.addEventListener('keydown', this.handleKeyPress);
使用声明周期的方法管理更新的数据		componentWillReceiveProps(nextProps) {
    console.log(this.props, nextProps);
  }
					componentWillUpdate->componentWillReceiveProps->componentDidUpdate
使用shouldComponentUpdate重新渲染		shouldComponentUpdate(nextProps, nextState) {
    console.log('Should I update?');
 if(nextProps.value % 2 == 0) {
       return true;
     }
    return false;
    
介绍内联样式				
在react 中增加内联样式			style={styles}
--
在react render 方法中使用高级的JavaScript 	
if/else 条件判断				返回不同的 return

使用 && 获取更简洁的条件			{this.state.display && <h1>Displayed!</h1>}
使用三元表达式进行条件渲染			
从props 中有条理的渲染			
通过条件改变内联样式
使用 map()动态渲染元素			
为兄弟元素赋予唯一的键属性			
使用 filter() 过滤数组
使用 renderToString 在服务器上渲染 react	ReactDOMServer.renderToString(<App />);
--------------------redux----------------------
创建一个 redux store			let store = Redux.createStore(reducer);
从 react store 中获取state数据			const currentState = store.getState();

定义 redux 的 action				let action = {
    type: 'LOGIN'
}
定义 Action Creator				function actionCreator() {
    return action;
}
dispatch action 事件				store.dispatch(actionCreator());//store.dispatch({ type: 'LOGIN' });
处理store 的 action				if(action.type === 'LOGIN') {
    return {
      login: true,
    }
  }
使用 switch 处理多个 action
将 const 用于 action type			设置全局变量就对了
--------------
注册商店监听器				store.subscribe(() => {
  count+=1;
})
结合多个 reducers				const rootReducer = Redux.combineReducers({ auth: authenticationReducer, notes: notesReducer });
将 action 数据传输到store			return {
    type: ADD_NOTE,
    text: note
  }
使用中间件处理异步请求			在 createStore 中传入参数Redux.applyMiddleware(ReduxThunk.default) 便可完成异步请求
用 redux 写一个计时器			完整流程，值得看看
绝不改变 state				
在数组中使用 Spread Operator		return [...state, action.todo];
从数组中删除一个项
---------------react redux---------------------------
开始react redux
首先管理本地的 state
将状态逻辑提取到redux
使用 provider 将 redux 链接到 react 上		const Provider = ReactRedux.Provider;	<Provider store={store}> <DisplayMessages/> </Provider>
将 state 映射到 props 上	co		创建方法将 state 传递进方法中，返回 obj对象
通过 dispatch 映射到 props 上
将 dispatch 映射到 props 上			submitNewMessage: function (newMessage) {dispatch(addMessage(newMessage));}
链接 react 和 redux				const connect = ReactRedux.connect;   /.  const ConnectedComponent = connect(mapStateToProps, mapDispatchToProps)(Presentational);
将 redux 连接到 消息 app 中			const Container = connect(mapStateToProps, mapDispatchToProps)(Presentational); 然后当成组件来引用		很详细的demo 可直接打开查看
将本地state 数据提取到 redux 上			详细的 demo 

------------数据可视化项目------------------

用 D3添加文档元素				 d3.select('body').append('h1').text('Learning D3');
使用D3 选择一组元素				d3.selectAll('li').text('list item');
使用 D3中的数据				d3.select('body').selectAll('h2').data(dataset).enter().append("h2").text('New Title');
在D3 中使用动态数据				selection.text((d) => d)
向元素添加内联样式				selection.style("color","blue");
基于数据改变样式				style.('color', (d) => { if( return ) } )
在 D3 中添加类					selection.attr("class", "container");
动态更新元素的高度				
更改条形图的显示				
学习 D3 中的 SVG				 .append('svg') .attr('width', w) .attr('height', h)
使用 svg 显示形状				.append('rect') .attr('x', 0) .attr('y', 0)
为集合中的‘每个元素创建一个柱状图
动态设置每个柱状图的宽度
动态设置每个柱状图的高度
反转 svg 元素					h - m * d
将标签添加到 D3 元素				
设置 标签元素的样式
为 d3 元素添加悬停效果				bar:hover(fill: brown;)	.attr('class', 'bar')
给 d3 元素添加 tooltip				.append('title').text()
-
使用 svg 圈创建散点图
20
给圆元素加上样式				.append('circle').attr('cx').attr('cy').attr('y')
给每个散点加上坐标				
使用d3 创建线性比例				const scale = d3.scaleLinear()
在比例上设置域和范围			scale.domain([250, 500]);    scale.range([10, 150]);
使用 d3.max 和 d3.min 方法来查找data 中的最大值和最小值	const output = d3.max(positionData, (d) => {      return d3.max(d)    });
使用动态比例            const yScale = d3.scaleLinear() .domain([0, d3.max(dataset, (d) => d[1])])  .range([w - padding, padding]);
使用预定义比例放置元素    
将轴添加到可视化中      const xAxis = d3.axisBottom(xScale);    svg.append("g").attr("transform", "translate(0, " + (h - padding) + ")").call(xAxis);

------------ajax-----------------

通过 javascript 使用 onclick 属性来绑定点击事件 document.getElementById('~').onclick = function() {}
通过点击事件来改变text 文本 document.getElementsByClassName('~')[0].textContent = '~';
通过 javascript 的 XMLHttpRequest 方法来获取 json   看文档 第 978 行
从 API 中访问 JOSN 数据   
将 json 数据转化为 HTML   
从数据源渲染图像    
预过滤JOSN 以获取所需的 数据    json = json.filter(item => { item.id !== 1 })
获取地理位置数据，以查找用户的GPS坐标       看文档 第 991 行
使用 javascript XMLHttpRequest 的方法发布数据   看文档 1003 行	

--------npm Node package Manager------------

package.json 中的 dependencies-section 的 npm 包的版本遵循所谓的语意版本控制(SemVer)， 在 npm 上发布的库，版本，框架或者其他工具应该使用SemVer ，以便清楚的传达依赖与程序包的项目在更新是时，可以期望的更改类型。 

Tilde-Character：始终使用依赖项的最新修补程序版本。如果你需要确保项目中的不同部分彼此兼容，这是冻结依赖关系有用的方法。

使用波浪号 - 字符（〜）为依赖项中的时刻版本添加前缀，并允许npm将其更新为任何新的PATCH版本。

```json
"some-package-name": "~1.3.8" allows updates to any 1.3.x version
```
Caret-Character: 使用最新的次要版本的依赖项。插入符号（^）也允许 npm 安装将来的更新

----------basic node and express-------------

node.js 允许用 js 编写后端程序，核心模块： 

HTTP: 充当服务器模块

文件系统： 读取和修改文件的模块

路径： 用于处理目录和文件路径的模块

断言：根据规定的约束检查代码的模块

Express 不在 node.js 之间。

Express 在 node.js 中创建的服务器和 web 应用程序的前端页面间运行。并且还处理应用程序的路由
















		

